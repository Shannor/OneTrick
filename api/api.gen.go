// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ActivityHistory defines model for ActivityHistory.
type ActivityHistory struct {
	// ActivityHash Hash id of the type of activity: Strike, Competitive, QuickPlay, etc.
	ActivityHash int64 `json:"activityHash"`

	// InstanceId Id to get more details about the particular game
	InstanceId string `json:"instanceId"`
	IsPrivate  *bool  `json:"isPrivate,omitempty"`

	// Mode Name of the Destiny Activity Mode
	Mode        *string `json:"mode,omitempty"`
	ReferenceId int64   `json:"referenceId"`
}

// BaseItemInfo defines model for BaseItemInfo.
type BaseItemInfo struct {
	BucketHash *int    `json:"bucketHash,omitempty"`
	InstanceId *string `json:"instanceId,omitempty"`
	ItemHash   *int    `json:"itemHash,omitempty"`
	Name       *string `json:"name,omitempty"`
}

// ItemDetails The response object for retrieving an individual instanced item. None of these components are relevant for an item that doesn't have an "itemInstanceId": for those, get your information from the DestinyInventoryDefinition.
type ItemDetails struct {
	BaseInfo *BaseItemInfo `json:"baseInfo,omitempty"`

	// CharacterId If the item is on a character, this will return the ID of the character that is holding the item.
	CharacterId *string `json:"characterId"`

	// Perks Information specifically about the perks currently active on the item. COMPONENT TYPE: ItemPerks
	Perks *[]Perk `json:"perks,omitempty"`

	// Sockets Information about the sockets of the item: which are currently active, what potential sockets you could have and the stats/abilities/perks you can gain from them. COMPONENT TYPE: ItemSockets
	Sockets *[]Socket `json:"sockets,omitempty"`

	// Stats Information about the computed stats of the item: power, defense, etc... COMPONENT TYPE: ItemStats
	Stats *Stats `json:"stats,omitempty"`
}

// Perk defines model for Perk.
type Perk struct {
	// Hash The hash ID of the perk
	Hash *int `json:"hash,omitempty"`

	// IconPath link to icon
	IconPath *string `json:"iconPath,omitempty"`

	// IsActive Whether the perk is active or not.
	IsActive *bool `json:"isActive,omitempty"`

	// Visible Whether the perk is visible or not.
	Visible *bool `json:"visible,omitempty"`
}

// Pong defines model for Pong.
type Pong struct {
	Ping string `json:"ping"`
}

// Socket defines model for Socket.
type Socket struct {
	// IsEnabled Whether the socket plug is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// IsVisible Whether the socket plug is visible or not.
	IsVisible *bool `json:"isVisible,omitempty"`

	// PlugHash The hash ID of the socket plug.
	PlugHash *int `json:"plugHash,omitempty"`
}

// Stats defines model for Stats.
type Stats map[string]struct {
	// StatHash The hash ID of the stat.
	StatHash *int `json:"statHash,omitempty"`

	// Value The value of the stat.
	Value *int `json:"value,omitempty"`
}

// StatsValue defines model for StatsValue.
type StatsValue struct {
	// ActivityId When a stat represents the best, most, longest, fastest or some other personal best, the actual activity ID where that personal best was established is available on this property.
	ActivityId *int64 `json:"activityId"`

	// Basic Basic stat value.
	Basic *StatsValuePair `json:"basic,omitempty"`

	// Pga Per game average for the statistic, if applicable
	Pga *StatsValuePair `json:"pga,omitempty"`

	// StatId Unique ID for this stat
	StatId *string `json:"statId,omitempty"`

	// Weighted Weighted value of the stat if a weight greater than 1 has been assigned.
	Weighted *StatsValuePair `json:"weighted,omitempty"`
}

// StatsValuePair defines model for StatsValuePair.
type StatsValuePair struct {
	// DisplayValue Localized formatted version of the value.
	DisplayValue *string `json:"displayValue,omitempty"`

	// Value Raw value of the statistic
	Value *float64 `json:"value,omitempty"`
}

// WeaponStats defines model for WeaponStats.
type WeaponStats struct {
	// ItemDetails The response object for retrieving an individual instanced item. None of these components are relevant for an item that doesn't have an "itemInstanceId": for those, get your information from the DestinyInventoryDefinition.
	ItemDetails *ItemDetails `json:"details,omitempty"`

	// ReferenceId The hash ID of the item definition that describes the weapon.
	ReferenceId *uint32 `json:"referenceId,omitempty"`

	// Stats Collection of stats for the period.
	Stats *map[string]StatsValue `json:"stats,omitempty"`
}

// GetActivitiesParams defines parameters for GetActivities.
type GetActivitiesParams struct {
	Count int64 `form:"count" json:"count"`
	Page  int64 `form:"page" json:"page"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /activities)
	GetActivities(c *gin.Context, params GetActivitiesParams)

	// (GET /activities/{activityId})
	GetActivity(c *gin.Context, activityId string)

	// (GET /ping)
	GetPing(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetActivities operation middleware
func (siw *ServerInterfaceWrapper) GetActivities(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetActivitiesParams

	// ------------- Required query parameter "count" -------------

	if paramValue := c.Query("count"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument count is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "count", c.Request.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter count: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "page" -------------

	if paramValue := c.Query("page"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument page is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetActivities(c, params)
}

// GetActivity operation middleware
func (siw *ServerInterfaceWrapper) GetActivity(c *gin.Context) {

	var err error

	// ------------- Path parameter "activityId" -------------
	var activityId string

	err = runtime.BindStyledParameterWithOptions("simple", "activityId", c.Param("activityId"), &activityId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter activityId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetActivity(c, activityId)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPing(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/activities", wrapper.GetActivities)
	router.GET(options.BaseURL+"/activities/:activityId", wrapper.GetActivity)
	router.GET(options.BaseURL+"/ping", wrapper.GetPing)
}

type GetActivitiesRequestObject struct {
	Params GetActivitiesParams
}

type GetActivitiesResponseObject interface {
	VisitGetActivitiesResponse(w http.ResponseWriter) error
}

type GetActivities200JSONResponse []ActivityHistory

func (response GetActivities200JSONResponse) VisitGetActivitiesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetActivityRequestObject struct {
	ActivityId string `json:"activityId"`
}

type GetActivityResponseObject interface {
	VisitGetActivityResponse(w http.ResponseWriter) error
}

type GetActivity200JSONResponse struct {
	Activity ActivityHistory `json:"activity"`
	Stats    []WeaponStats   `json:"stats"`
}

func (response GetActivity200JSONResponse) VisitGetActivityResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPingRequestObject struct {
}

type GetPingResponseObject interface {
	VisitGetPingResponse(w http.ResponseWriter) error
}

type GetPing200JSONResponse Pong

func (response GetPing200JSONResponse) VisitGetPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {

	// (GET /activities)
	GetActivities(ctx context.Context, request GetActivitiesRequestObject) (GetActivitiesResponseObject, error)

	// (GET /activities/{activityId})
	GetActivity(ctx context.Context, request GetActivityRequestObject) (GetActivityResponseObject, error)

	// (GET /ping)
	GetPing(ctx context.Context, request GetPingRequestObject) (GetPingResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetActivities operation middleware
func (sh *strictHandler) GetActivities(ctx *gin.Context, params GetActivitiesParams) {
	var request GetActivitiesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetActivities(ctx, request.(GetActivitiesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetActivities")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetActivitiesResponseObject); ok {
		if err := validResponse.VisitGetActivitiesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetActivity operation middleware
func (sh *strictHandler) GetActivity(ctx *gin.Context, activityId string) {
	var request GetActivityRequestObject

	request.ActivityId = activityId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetActivity(ctx, request.(GetActivityRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetActivity")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetActivityResponseObject); ok {
		if err := validResponse.VisitGetActivityResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPing operation middleware
func (sh *strictHandler) GetPing(ctx *gin.Context) {
	var request GetPingRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPing(ctx, request.(GetPingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPing")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPingResponseObject); ok {
		if err := validResponse.VisitGetPingResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//8NPCT24FQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
